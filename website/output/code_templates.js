window.code_templates = {"binary_tree_in_cc":{"files":[{"name":"Runner","value":"cc_gtest_1_7_0\n"},{"name":"code.cc","value":"#include \"code.h\"\nusing namespace std;\n\nint count_nodes(node *tree) {\n    if (tree == NULL) {\n        return 0;\n    }\n    return 1 + count_nodes(tree->left) + count_nodes(tree->right);\n}\n\nnode* bal_tree_add(node *tree, int value) {\n\n    if (tree == NULL) {\n        // No tree exists, or went off the bottom\n        return new node(value);\n    }\n    else {\n        if (value < tree->value) {\n            tree->left = bal_tree_add(tree->left, value);\n        }\n        else {\n            tree->right = bal_tree_add(tree->right, value);\n        }\n    }\n    tree = balance_tree(tree);\n    return tree;\n}\n\nnode* move_left(node *tree) {\n    node *r = tree->right;\n    node *rl = r->left;\n    tree->right = rl;\n    r->left = tree;\n    set_height(tree);\n    set_height(r);\n    return r;\n}\n\nnode* move_right(node *tree) {\n    node *l = tree->left;\n    node *lr = l->right;\n    tree->left = lr;\n    l->right = tree;\n    set_height(tree);\n    set_height(l);\n    return l;\n}\n\nnode* swing_left(node *tree) {\n\n    node *r = tree->right;\n    node *rr = r->right;\n    node *rl = r->left;\n    node *l = tree->left;\n\n    int lh = (l == NULL) ? 0 : l->height;\n    int rlh = (rl == NULL) ? 0 : rl->height;\n    int rrh = (rr == NULL) ? 0 : rr->height;\n\n    if (rlh > rrh) {\n        tree->right = move_right(r);\n    }\n\n    return move_left(tree);\n\n}\n\nnode* swing_right(node *tree) {\n\n    node *l = tree->left;\n    node *lr = l->right;\n    node *ll = l->left;\n    node *r = tree->right;\n\n    int rh = (l == NULL) ? 0 : l->height;\n    int lrh = (lr == NULL) ? 0 : lr->height;\n    int llh = (ll == NULL) ? 0 : ll->height;\n\n    if (lrh > llh) {\n        tree->left = move_left(l);\n    }\n\n    return move_right(tree);\n\n}\n\nnode* balance_tree(node *tree) {\n    if (tree == NULL) {\n        return tree;\n    }\n\n    node *l = tree->left;\n    int lh = (l == NULL) ? 0 : l->height;\n    node *r = tree->right;\n    int rh = (r == NULL) ? 0 : r->height;\n\n    if (lh > rh + 1) {\n        swing_right(tree);\n    }\n    else if (rh > lh + 1) {\n        swing_left(tree);\n    }\n    else {\n        set_height(tree);\n        return tree;\n    }\n}\n\nvoid set_height(node *tree) {\n    node *l = tree->left;\n    int lh = (l == NULL) ? 0 : l->height;\n    node *r = tree->right;\n    int rh = (r == NULL) ? 0 : r->height;\n\n    //cout << \"l: \" << lh << \"\\n\";\n    //cout << \"r: \" << rh << \"\\n\";\n\n    tree->height = (rh > lh) ? rh + 1 : lh + 1;\n}\n\nnode* bal_tree_find(node *tree, int value) {\n    while (tree != NULL) {\n        if (value == tree->value) {\n            return tree;\n        }\n        else if (value < tree->value) {\n            tree = tree->left;\n        }\n        else {\n            tree = tree->right;\n        }\n    }\n    return NULL;\n}\n\n// Give this function a tree and an empty node pointer vector, it\n// will fill the vector with the values in the tree.\nvoid bal_tree_traverse(node *tree, std::vector<node*> & vec) {\n\n    if (tree == NULL) {\n        return;\n    }\n    else {\n        if (tree->left != NULL) {\n            bal_tree_traverse(tree->left, vec);\n        }\n        vec.push_back(tree);\n        if (tree->right != NULL) {\n            bal_tree_traverse(tree->right, vec);\n        }\n    }\n}\n"},{"name":"code.h","value":"#ifndef CS_CODE_\n#define CS_CODE_\n\n#include <iostream>\n#include <vector> // Used to check the traverse values of the tree\n#include <string> // Used to create a pretty printed version of the tree\n\nstruct node\n{\n    int value;\n    node *left;\n    node *right;\n    int height;\n\n    node(int x) {\n        value = x;\n        left = NULL;\n        right = NULL;\n        height = 1;\n    }\n};\n\nint count_nodes(node *tree);\nnode* bal_tree_add(node *tree, int value);\nnode* bal_tree_find(node *tree, int value);\nnode* move_left(node *tree);\nnode* move_right(node *tree);\nnode* swing_right(node * tree);\nnode* swing_left(node * tree);\nnode* balance_tree(node *tree);\nvoid set_height(node *tree);\nvoid bal_tree_traverse(node *tree, std::vector<node*> & vec);\n\n#endif  // CS_CODE_\n"},{"name":"unittests.cc","value":"#include \"code.h\"\n#include <gtest/gtest.h>\n\n#include <sstream> //required by the itos function below\n\nstd::string itos(int i) // convert int to string\n{\n    std::stringstream s;\n    s << i;\n    return s.str();\n}\n\n// Traverse returns a vector of node pointers\n// that can be pretty printed into a string by this function\nstd::string vector_pretty_print(std::vector<node*>& vec) {\n\n    std::string results = \"\\n\";\n    int vec_size = vec.size();\n    for (int x = 0; x < vec_size; x++) {\n        node *tree = vec[x];\n        for (int y = 0; y < tree->height; y++) {\n            results.append(\"    \");\n        }\n        results.append(itos(tree->value));\n        results.append(\"\\n\");\n    }\n    return results;\n}\n\nTEST(BinaryTreeTestGrouping, CountTree) {\n    // Build a tree manually counting the nodes while it's created\n    node *tree = new node(4);\n    EXPECT_EQ(1, count_nodes(tree));\n\n    tree->left = new node(2);\n    EXPECT_EQ(2, count_nodes(tree));\n\n    tree->right = new node(6);\n    EXPECT_EQ(3, count_nodes(tree));\n\n    tree->right->left = new node(5);\n    tree->right->right = new node(7);\n    EXPECT_EQ(5, count_nodes(tree));\n\n}\n\nTEST(BinaryTreeTestGrouping, BalTreeAdd) {\n    node *tree = bal_tree_add(NULL, 4);\n    EXPECT_EQ(1, count_nodes(tree));\n    EXPECT_EQ(1, tree->height);\n\n    tree = bal_tree_add(tree, 6);\n    EXPECT_EQ(2, count_nodes(tree));\n    EXPECT_EQ(2, tree->height);\n\n    tree = bal_tree_add(tree, 2);\n    EXPECT_EQ(3, count_nodes(tree));\n    EXPECT_EQ(2, tree->height);\n\n    // These will be added to the left side.\n    // The tree height will raise to 3.\n    tree = bal_tree_add(tree, 10);\n    tree = bal_tree_add(tree, 12);\n    EXPECT_EQ(3, tree->height);\n\n    // These will add to the right side.\n    // The tree's height will stay the same.\n    tree = bal_tree_add(tree, 1);\n    tree = bal_tree_add(tree, 3);\n    EXPECT_EQ(3, tree->height);\n\n    // The tree is full and balanced.\n    // Adding one more element will increase the tree height.\n    tree = bal_tree_add(tree, 5);\n    EXPECT_EQ(4, tree->height);\n}\n\nTEST(BinaryTreeTestGrouping, BalTreeFind) {\n    node *tree = bal_tree_add(NULL, 4);\n    EXPECT_EQ(1, count_nodes(tree));\n\n    tree = bal_tree_add(tree, 6);\n    EXPECT_EQ(2, count_nodes(tree));\n\n    tree = bal_tree_add(tree, 2);\n    EXPECT_EQ(3, count_nodes(tree));\n\n    EXPECT_EQ(6, bal_tree_find(tree, 6)->value);\n    EXPECT_EQ(NULL, bal_tree_find(tree, 10));\n\n}\n\nTEST(BinaryTreeTestGrouping, SimpleBalTreeTraverse) {\n    node *tree = bal_tree_add(NULL, 4);\n    tree = bal_tree_add(tree, 6);\n    tree = bal_tree_add(tree, 2);\n    tree = bal_tree_add(tree, 10);\n    tree = bal_tree_add(tree, 12);\n    tree = bal_tree_add(tree, 8);\n\n    std::vector<node*> vec;\n    bal_tree_traverse(tree, vec);\n\n    std::string expected = \"\\n\";\n    expected.append(\"    2\\n\");\n    expected.append(\"        4\\n\");\n    expected.append(\"            6\\n\");\n    expected.append(\"    8\\n\");\n    expected.append(\"        10\\n\");\n    expected.append(\"    12\\n\");\n\n    std::string results = vector_pretty_print(vec);\n\n    EXPECT_EQ(expected, results);\n}\n\nTEST(BinaryTreeTestGrouping, ComplexBalTreeTraverse) {\n    node *tree = bal_tree_add(NULL, 4);\n    tree = bal_tree_add(tree, 6);\n    tree = bal_tree_add(tree, 2);\n    tree = bal_tree_add(tree, 10);\n    tree = bal_tree_add(tree, 12);\n    tree = bal_tree_add(tree, 8);\n    // Here's where it deviates from the SimpleBalTreeTraverse function\n    tree = bal_tree_add(tree, 5);\n    tree = bal_tree_add(tree, 14);\n    tree = bal_tree_add(tree, 11);\n\n    std::vector<node*> vec;\n    bal_tree_traverse(tree, vec);\n\n    std::string expected = \"\\n\";\n    expected.append(\"    2\\n\");\n    expected.append(\"        4\\n\");\n    expected.append(\"    5\\n\");\n    expected.append(\"                6\\n\");\n    expected.append(\"    8\\n\");\n    expected.append(\"            10\\n\");\n    expected.append(\"    11\\n\");\n    expected.append(\"        12\\n\");\n    expected.append(\"    14\\n\");\n\n    std::string results = vector_pretty_print(vec);\n\n    EXPECT_EQ(expected, results);\n}\n\nint main(int argc, char **argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n"}]},"factorial_in_clojure":{"files":[{"name":"Runner","value":"clojure_1_6_0\n"},{"name":"code.clj","value":"(defn fact [x]\n    (loop [n x f 1]\n        (if (= n 1)\n            f\n            (recur (dec n) (* f n)))))\n"},{"name":"unittests.clj","value":";[tag:note:gem] I'm positive that this test could be better using some kind of\n;sequence comparison.  Please improve, and also make the code idiomatic as\n;well.\n\n(ns this.test.namespace\n   (:use clojure.test))\n\n(load-file \"./code.clj\")\n\n(deftest test-adder\n  (is (= 1  (fact 1)))\n  (is (= 2  (fact 2)))\n  (is (= 6  (fact 3)))\n)\n\n(run-tests 'this.test.namespace)\n"}]},"factorial_in_haskell":{"files":[{"name":"Code.hs","value":"module Code ( fac ) where\n\nfac n = if n == 0 then 1 else n * fac (n-1)\n"},{"name":"Runner","value":"haskell\n"},{"name":"unittests.hs","value":"import Code\n\nimport Test.HUnit\n\ntest0 = TestCase (assertEqual \"factorial for 0\" (1) (fac 0))\ntest1 = TestCase (assertEqual \"factorial for 1\" (1) (fac 1))\ntest2 = TestCase (assertEqual \"factorial for 2\" (2) (fac 2))\ntest3 = TestCase (assertEqual \"factorial for 3\" (6) (fac 3))\ntest4 = TestCase (assertEqual \"factorial for 4\" (24) (fac 4))\ntest5 = TestCase (assertEqual \"factorial for 5\" (120) (fac 5))\n\nmain = runTestTT $ TestList [test0, test1, test2, test3, test4, test5]\n"}]},"factorial_in_rust":{"files":[{"name":"Runner","value":"rust_0_10\n"},{"name":"code.rs","value":"fn factorial(value: int) -> int {\n  if value == 0 {\n    return 1;\n  }\n  else {\n    return value * factorial(value-1);\n  }\n}\n\n#[test]\nfn test_factorial() {\n  assert!(factorial(0) == 1)\n  assert!(factorial(1) == 1)\n  assert!(factorial(2) == 2)\n  assert!(factorial(3) == 6)\n  assert!(factorial(4) == 24)\n}\n"}]},"kmp_in_python":{"files":[{"name":"Runner","value":"python_2_7_6\n"},{"name":"code.py","value":"# File: code.py\n# Author: Keith Schwarz (htiek@cs.stanford.edu)\n#\n# An implementation of the Knuth-Morris-Pratt (KMP) string-matching algorithm.\n# This algorithm takes as input a pattern string P and target string T, then\n# finds the first occurrence of the string T in the pattern P, doing so in time\n# O(|P| + |T|).  The logic behind the algorithm is not particularly complex,\n# though getting it to run in linear time requires a few non-obvious tricks.\n#\n# To motivate KMP, consider the naive algorithm for trying to match a pattern\n# string P against a target T.  This would work by considering all possible\n# start positions for the pattern P in the target T, then checking whether a\n# match exists at each of those positions.  For example, to match the string\n# ABC against the target string ABABABACCABC, we'd get\n#\n#     ABABABACCABC\n#     ABX               (first two characters match, last does not)\n#      X                (first character doesn't match)\n#       ABX             (first two characters match, last does not)\n#        X              (first character doesn't match)\n#         ABX           (first two characters match, last does not)\n#          X            (first character doesn't match)\n#           AX          (first character matches, second doesn't)\n#            X          (first character doesn't match)\n#             X         (first character doesn't match)\n#              ABC      (match found)\n#\n# This algorithm runs in O(mn) in the worst case, where m = |T| and n = |P|,\n# because it has to do O(n) work to check whether the string matches O(m) times\n# for each spot in the string.\n#\n# However, a lot of this is wasted work.  For example, in the above example,\n# consider what happens when we know that the string ABC does not match the\n# first part of the string, ABA.  At this point, it would be silly to actually\n# try to match the string at the string starting with the B, since there's no\n# possible way that the string could match there.  Instead, it would make more\n# sense to instead start over and try matching ABC at the next A.  In fact,\n# more generally, if we can use the information we have about what characters\n# we already matched to determine where we should try to resume the search in\n# the string, we can avoid revisiting characters multiple times when there's no\n# hope that they could ever match.\n#\n# The idea we'll use is to look for \"borders\" of a string, which are substrings\n# that are both a prefix and suffix of the string.  For example, the string\n# \"aabcaa\" has \"aa\" as a border, while the string \"abc\" just has the empty\n# string as a border.  Borders are useful in KMP because they encode\n# information about where we might need to pick up the search when a particular\n# match attempt fails.  For example, suppose that we want to match ABABC\n# against the string ABABABC.  If we start off by trying to match the string,\n# we'll find that they overlap like this:\n#\n#    ABABABC\n#    ABABx\n#\n# That is, the first four characters match, but the fifth does not.  At this\n# point, rather than naively restarting the search at the second character (B),\n# or even restarting it at the third position (A), we can instead note that we\n# can treat the last two characters of the string we matched (AB) as the first\n# two characters of the pattern string ABABC if we just treated it instead as\n# though we had\n#\n#    ABABABC\n#    ABABx\n#      ABABC\n#\n# If we can somehow remember the fact that we already matched the AB at the\n# start of this string, we could just confirm that the three characters after\n# it are ABC and be done.  There's no need to confirm that the characters at\n# the front match.\n#\n# In order to make this possible, we'll construct a special data structure\n# called the \"fail table.\"  This table stores, for each possible prefix of the\n# string to match, the length of the longest border of that prefix.  That way,\n# when we find a mismatch, we know where the next possible start location could\n# be found.  In particular, once we have a mismatch, if there's any border of\n# the prefix of the pattern that we matched so far, then we can treat the end\n# of that matching prefix as the start of a prefix of the word that occurs\n# later in the target.\n#\n# The basic idea behind KMP is, given this table, to execute the following:\n#\n#  - Guess that the string starts at the beginning of the target.\n#  - Match as much of the string as possible.\n#  - If the whole string matched, we're done.\n#  - Otherwise, a mismatch was found.  Look up the largest border of the\n#    string that was matched so far in the failure table.  Suppose it has\n#    length k.\n#  - Update our guess of the start position to be where that border occurs\n#    in the portion matched so far, then repeat this process.\n#\n# Notice that once we've matched a character against part of the pattern (or\n# found that it can't possibly match), we never visit that character again.\n# This is responsible for the fast runtime of the algorithm (though I'll give a\n# more formal description later on).\n\n# Function: failTable(pattern)\n# Usage: failTable(\"This is a string!\")\n# -----------------------------------------------------------------------------\n# Given a string, constructs the KMP failure table for that string.  The values\n# in the table are defined as\n#\n#    table[i] = |LongestProperBoundary(pattern[0:i)])|\n#\n# Where the longest proper boundary of a string is the longest proper substring\n# of that string that is both a prefix and a suffix.  For example, given the\n# string \"abcabc,\" the longest proper boundary is abc.  Similarly, given the\n# string \"apple,\" the longest proper boundary is the empty string.\n#\n# As a sample output of this function, given the string \"ababcac\", the table\n# would be\n#\n#     a b a b c a c\n#    * 0 0 1 2 0 1 0\n#\n# This means, for example, that the longest proper boundary of the prefix \"aba\"\n# has length 1, while the longest proper boundary of the string as a whole is\n# the empty string.  Notice that the first entry is *, which we have chosen\n# because there is no mathematically well-defined proper substring of the empty\n# string.  We can put anything we want there, and we'll go with None.\n#\n# To compute the values of this table, we use a dynamic programming algorithm\n# to compute a slightly stronger version of the function.  We define the\n# function \"Extended Longest Proper Boundary\" (xLPB) as follows:\n#\n#    xLPB(string, n, char) = The longest proper boundary of string[0:n] + char\n#\n# The idea behind this function is that we want to be able to recycle the\n# values of the longest proper boundary function for smaller prefixes of the\n# string in order to compute the longest proper boundary for longer prefixes.\n# To make this easier, the xLPB function allows us to talk about what would\n# happen if we extended the longest proper boundary of some prefix of the\n# string by a single character.  Notice that for any nonzero n, we have that\n#\n#   LongestProperBoundary(string[0:n]) = xLPB(string, n - 1, string[n])\n#\n# That is, we simply tear off the last character and use it as the final\n# argument to xLPB.  Given this xLPB function, we can compute its values\n# recursively using the following logic.  As a base case, xLPB(string, 0, char)\n# is the longest proper boundary of string[0:0] + char = char.  But this has\n# only one proper boundary, the empty string, and so its value must be zero.\n#\n# Now suppose that for all n' < n we have the value of xLPB(string, n', char)\n# for any character char.  Suppose we want to go and compute\n# xLPB(string, n, char).  Let's think about what this would mean.  Given that\n# n is not zero, we can think of this problem as trying to find the longest\n# proper boundary of this string:\n#\n#     +------------+---+------------+------------+---+\n#     |     LPB    | ? |    ...     |     LPB    | c |\n#     +------------+---+------------+------------+---+\n#\n#     ^                                          ^ ^\n#     +----------------------+-------------------+ |\n#                            |                     |\n#                   String of length n      New character\n#\n# The idea is that we have the original string of length n, followed by our new\n# character char (which we'll abbreviate c).  In this diagram, I've marked the\n# LPB of the string of length n.  Notice that right after the LPB at the prefix\n# of the string, we have some character whose value is unknown (since n != 0\n# and the LPB can't be the whole string).  If this value is equal to c, then\n# the LPB of the whole string can be formed by simply extending the LPB of the\n# first n characters.  There can't be a longer proper boundary, since otherwise\n# we could show that by taking that longer boundary and dropping off the\n# character c, we'd end up with a longer proper boundary for the first n\n# characters of the string, contradicting that we chose the longest proper\n# boundary.\n#\n# By our above argument, remember that the length of the longest proper\n# boundary of the first n characters of the string is given by\n#\n#    xLPB(string, n - 1, string[n - 1])\n#\n# Thus we have the first part of our recurrence, which is defined as\n#\n#    xLPB(string, n, char) =\n#        if n = 0, then 0.\n#        let k = xLPB(string, n - 1, string[n - 1])\n#        if string[k] == char, return k + 1\n#        else, ???\n#\n# Now, suppose that we find that the character after the LPB does not match.\n# If this happens, we can then make the following observation.  Below I've\n# reprinted the above diagram:\n#\n#     +------------+---+------------+------------+---+\n#     |     LPB    | ? |    ...     |     LPB    | c |\n#     +------------+---+------------+------------+---+\n#\n#     ^                                          ^ ^\n#     +----------------------+-------------------+ |\n#                            |                     |\n#                   String of length n      New character\n#\n# Notice that any LPB of this new string must be a prefix of the LPB of the\n# first n characters and a suffix of the LPB followed by the character c.\n# Since by definition the LPB of the first n characters must be a prefix of\n# those n characters, we have the following elegant conclusion to our\n# recurrence:\n#\n#    xLPB(string, n, char) =\n#        if n = 0, then 0.\n#        let k = xLPB(string, n - 1, string[n - 1])\n#        if string[k] == char, return k + 1\n#        else, xLPB(string, k, char)\n#\n# The reason for this is that xLPB(string, k, char) asks for the longest\n# proper boundary of the LPB of the string formed from the first n characters\n# of the string followed by the character c, which is exactly what we described\n# above.\n#\n# As written, filling in the table of LPB values would take O(n^2) time, where\n# n is the length of the string.  However, using dynamic programming and an\n# amortized analysis, we can show that this function can be made to run in\n# O(n) time.  In particular, suppose that for all n' < n, we know the value of\n# LPB(string[0:n]).  Then in the above formulation of xLPB, the first\n# recursive call is known, and the only recursive call we may actually need to\n# make is the second.\n#\n# However, this doesn't seem to say anything about the runtime of the second\n# recursive call, which seems as though it might cause the evaluation of this\n# function to run in time O(n).  This is correct, but in an *amortized* sense\n# the whole table can still be computed in O(n) time overall.  To see this,\n# let's define a potential function Phi(k) that associates a potential at each\n# point of the computation of the table.  In particular, define Phi(k) as\n#\n#   Phi(0)     = 0\n#   Phi(k + 1) = result[k - 1]\n#\n# Here, result is the resulting table of LPB values.  Because of this, we can\n# remark that result[k] < k, since the longest proper border of a string can't\n# be any longer than that string.\n#\n# Let's now show that this potential function gives an amortized O(1) cost for\n# each table entry computation, and thus an O(n) overall runtime for the table-\n# building algorithm.  To see this, consider what happens when the logic to\n# compute the next value runs.  The runtime for this step is bounded by the\n# number of recursive calls made to a subproblem.  However, each subproblem is\n# then of size given by the LPB of a slightly smaller problem.  This subproblem\n# must then have size at most the size of that smaller subproblem.  In other\n# words, we can say that each recursive call drops the maximum possible value\n# of the LPB for the current prefix by at least one.  Consequently, if k\n# recursive calls are made, the LPB of the current prefix is at least k smaller\n# than the LPB of the previous prefix, and so\n#\n#   D Phi = -k\n#\n# And so the amortized cost of computing the next term is 1 + k - k = O(1).\n\nmatch_index_instrument = [] #cfinstrument\nfail_instrument = [] #cfinstrument\n\ndef failTable(pattern):\n    # Create the resulting table, which for length zero is None.\n    result = [None]\n\n    # Iterate across the rest of the characters, filling in the values for the\n    # rest of the table.\n    for i in range(0, len(pattern)):\n        # Keep track of the size of the subproblem we're dealing with, which\n        # starts off using the first i characters of the string.\n        j = i\n\n        while True:\n            # If j hits zero, the recursion says that the resulting value is\n            # zero since we're looking for the LPB of a single-character\n            # string.\n            if j == 0:\n                result.append(0)\n                break\n\n            # Otherwise, if the character one step after the LPB matches the\n            # next character in the sequence, then we can extend the LPB by one\n            # character to get an LPB for the whole sequence.\n            if pattern[result[j]] == pattern[i]:\n                result.append(result[j] + 1)\n                break\n\n            # Finally, if neither of these hold, then we need to reduce the\n            # subproblem to the LPB of the LPB.\n            j = result[j]\n    \n    return result\n\n# Function: kmpMatch(needle, haystack)\n# Usage: print kmpMatch(\"0101\", \"0011001011\") # Prints 5\n# -----------------------------------------------------------------------------\n# Uses the KMP algorithm to find an occurrence of the specified needle string\n# in the haystack string.  To do this, we compute the failure table, which\n# is done above.  Next, we iterate across the string, keeping track of a\n# candidate start point and length matched so far.  Whenever a match occurs, we\n# update the length of the match we've made.  On a failure, we update these\n# values by trying to preserve the maximum proper border of the string we were\n# able to manage by that point.\ndef kmpMatch(needle, haystack):\n    del match_index_instrument[ 0:len(match_index_instrument) ] #cfinstrument\n    del fail_instrument[ 0:len(fail_instrument) ]               #cfinstrument\n\n    # Compute the failure table for the needle we're looking up.\n    fail = failTable(needle)\n\n    # Keep track of the start index and next match position, both of which\n    # start at zero since our candidate match is at the beginning and is trying\n    # to match the first character.\n    index = 0\n    match = 0\n\n    # Loop until we fall off the string or match.\n    while index + match < len(haystack):\n\n        # If the current character matches the expected character, then bump up\n        # the match index.\n        if haystack[index + match] == needle[match]:\n            match_index_instrument.append([index, match]) #cfinstrument\n            match = match + 1\n\n            # If we completely matched everything, we're done.\n            if match == len(needle):\n                return index\n\n        # Otherwise, we need to look at the fail table to determine what to do\n        # next.\n        else:\n            # If we couldn't match the first character, then just advance the\n            # start index.  We need to try again.\n            if match == 0:\n                index = index + 1\n\n            # Otherwise, see how much we need to skip forward before we have\n            # another feasible match.\n            else:\n                fail_instrument.append([index, match]) #cfinstrument\n                index = index + match - fail[match]\n                match = fail[match]\n                fail_instrument.append([index, match]) #cfinstrument\n\n    # If we made it here, then no match was found.\n    return None\n"},{"name":"unittests.py","value":"from code import *\n\nimport unittest\n\nclass TestKMPFunctions(unittest.TestCase):\n\n    def test_fail_table_with_no_repeated_characters(self):\n        self.assertEqual(failTable(\"ababcac\"), [None, 0, 0, 1, 2, 0, 1, 0])\n\n    def test_fail_table_with_en_present_three_times(self):\n        self.assertEqual(failTable(\"enlightenment\"), [None, 0, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 2, 0])\n\n    def test_fail_table_with_in_present_three_times(self):\n        self.assertEqual(failTable(\"pinpointing\"), [None, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0])\n\n    def test_word_doubled(self):\n        self.assertEqual(failTable(\"hotshots\"), [None, 0, 0, 0, 0, 1, 2, 3, 4])\n\n    def test_fail_table_unde_repeated_but_not_anchored_at_end_of_string(self):\n        self.assertEqual(failTable(\"underfunded\"), [None, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 0])\n\n    def test_fail_table_with_some_repeated_characters(self):\n        self.assertEqual(failTable(\"george\"), [None, 0, 0, 0, 0, 1, 2])\n\n    def test_match_at_beginning_of_string(self):\n        self.assertEqual(kmpMatch(\"george\", \"george likes geocaching\"), 0)\n\n        #cfinstrument_start\n        matchlist = [[0,0], [0,1], [0,2], [0,3], [0,4], [0,5]]\n        self.assertEqual(match_index_instrument, matchlist) #cfinstrument\n        #cfinstrument_end\n\n    def test_match_with_failures(self):\n\n        #                         14       23   28       37\n        #                         |__      |    |____    |_____\n        haystack = \"she mentioned geocaching to georgian george\"\n        #                                           |\n        #                                           32, but implicitly matched\n        #                                               by failTable so not in\n        #                                               match list\n\n        self.assertEqual(kmpMatch(\"george\", haystack), 37)\n\n        #cfinstrument_start\n        matchlist = [\n            [14,0], [14,1], [14,2],\n            [23,0],\n            [28,0], [28,1], [28,2], [28,3], [28,4],\n            [37,0], [37,1], [37,2], [37,3], [37,4], [37,5]\n        ]\n        self.assertEqual(match_index_instrument, matchlist)\n\n        faillist = [\n            [14, 3], [17, 0],\n            [23, 1], [24, 0],\n            [28, 5], [32, 1],\n            [32, 1], [33, 0]\n        ]\n        self.assertEqual(fail_instrument, faillist)\n        #cfinstrument_end\n\nif __name__ == '__main__':\n    unittest.main()\n"}]},"linked_list_in_cc":{"files":[{"name":"Runner","value":"cc_gtest_1_7_0\n"},{"name":"code.cc","value":"#include \"code.h\"\n\n// [tag:ptr_to_ptr:gem] See also the stack_cc for [tag:ref_to_ptr:gem] usage\nvoid append_node(node **list, int value) {\n    node *newnode = new node(value);\n\n    if (*list == NULL) {\n        *list = newnode;\n    }\n    else {\n        node *temp = *list;\n        while (temp->nxt != NULL) {\n            temp = temp->nxt;\n        }\n        temp->nxt = newnode;\n    }\n}\n\nbool insert_node(node **list, node *insert_after, node *newnode) {\n    if (*list == NULL) {\n        return false;\n    }\n    else {\n        node *temp = *list;\n        while (temp != NULL) {\n            if (temp == insert_after) {\n                node *after_splice = temp->nxt;\n                temp->nxt = newnode;\n                newnode->nxt = after_splice;\n                return true;\n            }\n            temp = temp->nxt;\n        }\n        return false;\n    }\n\n}\n\nint count_nodes(node **list) {\n    node *temp = *list;\n    if (temp == NULL) {\n        return 0;\n    }\n    else {\n        int counter = 0;\n        while (temp != NULL) {\n            counter++;\n            temp = temp->nxt;\n        }\n        return counter;\n    }\n}\n\nvoid delete_all_nodes(node **list) {\n    node *temp, *to_delete;\n    if (*list == NULL) {\n        return;\n    }\n    temp = *list;\n    while(temp->nxt != NULL) {\n        to_delete = temp;\n        temp = temp->nxt;\n        delete to_delete;\n    }\n    delete temp;\n    *list = NULL;\n}\n"},{"name":"code.h","value":"#ifndef CS_CODE_\n#define CS_CODE_\n\n#include <iostream>\n\nstruct node\n{\n    int value;\n    node *nxt;        // Pointer to next node\n\n    node(int x) {\n        value = x;\n        nxt = NULL;\n    }\n};\n\nvoid append_node(node **list, int value);\nbool insert_node(node **list, node *dest, node *newnode);\nint count_nodes(node **list);\nvoid delete_all_nodes(node **list);\n\n#endif  // CS_CODE_\n"},{"name":"unittests.cc","value":"#include \"code.h\"\n#include <gtest/gtest.h>\n\nTEST(NodesTestGrouping, AppendSomeNodes) {\n  node *list = NULL;\n  EXPECT_EQ(0, count_nodes(&list));\n  append_node(&list, 4);\n  EXPECT_EQ(1, count_nodes(&list));\n  append_node(&list, 3);\n  EXPECT_EQ(2, count_nodes(&list));\n}\n\nTEST(NodesTestGrouping, InsertNode) {\n  node *list = NULL;\n  EXPECT_EQ(0, count_nodes(&list));\n\n  // Cannot insert because the \"list\" pointer in the \"insert_after\" points to a\n  // null value.\n  EXPECT_EQ(false, insert_node(&list, list, new node(4)));\n\n  // Insert the first one at the non-existent head\n  append_node(&list, 1);\n\n  // Insert another one after the head\n  EXPECT_EQ(true, insert_node(&list, list, new node(4)));\n  EXPECT_EQ(2, count_nodes(&list));\n\n  // Insert another one after the head\n  EXPECT_EQ(true, insert_node(&list, list, new node(2)));\n  EXPECT_EQ(3, count_nodes(&list));\n\n  EXPECT_EQ(1, list->value);\n  EXPECT_EQ(2, list->nxt->value);\n  EXPECT_EQ(4, list->nxt->nxt->value);\n  EXPECT_EQ(NULL, list->nxt->nxt->nxt);\n\n  // Now, insert a 3 right after the 2, to fill in the gap\n  EXPECT_EQ(true, insert_node(&list, list->nxt, new node(3)));\n  EXPECT_EQ(4, count_nodes(&list));\n\n  EXPECT_EQ(1, list->value);\n  EXPECT_EQ(2, list->nxt->value);\n  EXPECT_EQ(3, list->nxt->nxt->value); // Newly inserted\n  EXPECT_EQ(4, list->nxt->nxt->nxt->value);\n  EXPECT_EQ(NULL, list->nxt->nxt->nxt->nxt);\n\n  // Finally, insert one at the end of the list\n  EXPECT_EQ(true, insert_node(&list, list->nxt->nxt->nxt, new node(5)));\n  EXPECT_EQ(5, count_nodes(&list));\n\n  EXPECT_EQ(1, list->value);\n  EXPECT_EQ(2, list->nxt->value);\n  EXPECT_EQ(3, list->nxt->nxt->value);\n  EXPECT_EQ(4, list->nxt->nxt->nxt->value);\n  EXPECT_EQ(5, list->nxt->nxt->nxt->nxt->value); // Newly inserted\n  EXPECT_EQ(NULL, list->nxt->nxt->nxt->nxt->nxt);\n\n}\n\nTEST(NodesTestGrouping, DeleteAllNodes) {\n  node *list = NULL;\n  EXPECT_EQ(0, count_nodes(&list));\n  append_node(&list, 4);\n  EXPECT_EQ(1, count_nodes(&list));\n  append_node(&list, 3);\n  EXPECT_EQ(2, count_nodes(&list));\n  delete_all_nodes(&list);\n  EXPECT_EQ(0, count_nodes(&list));\n}\n\nTEST(NodesTestGrouping, DeleteAllNodesEmptyList) {\n  node *list = NULL;\n  EXPECT_EQ(0, count_nodes(&list));\n  delete_all_nodes(&list);\n  EXPECT_EQ(0, count_nodes(&list));\n}\n\nint main(int argc, char **argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n"}]},"linked_list_in_go":{"files":[{"name":"Makefile","value":"include $(GOROOT)/src/Make.inc\n\nTARG=code\nGOFILES=\\\n\tcode.go\\\n\ninclude $(GOROOT)/src/Make.pkg\n"},{"name":"Runner","value":"golang_1_2_1\n"},{"name":"code.go","value":"package code\n\ntype Ele struct {\n    Data interface{}\n    Next *Ele\n}\n\nfunc (e *Ele) insert(data interface{}) {\n    if e == nil {\n        panic(\"attept to modify nil\")\n    }\n    e.Next = &Ele{data, e.Next}\n}\n"},{"name":"code_test.go","value":"package code\n\nimport \"testing\"\n\nfunc TestInsertElement(t *testing.T) {\n\n  h := &Ele{\"A\", nil}\n  if h.Data != \"A\" {\n    t.Errorf(\"data should be A but was %v\", h.Data)\n  }\n\n  h.insert(\"B\")\n  if h.Next.Data != \"B\" {\n    t.Errorf(\"data should be B but was %v\", h.Next.Data)\n  }\n\n  h.Next.insert(\"C\")\n  if h.Next.Next.Data != \"C\" {\n    t.Errorf(\"data should be C but was %v\", h.Next.Next.Data)\n  }\n\n}\n"}]},"linked_list_in_js":{"files":[{"name":"Runner","value":"javascript_karma_0_0_1\n"},{"name":"code.js","value":"function Node (value) {\n  if (value) {\n    this.value = value;\n  }\n  else {\n    this.value = \"default\";\n  }\n  this.pointer = null;\n}\n\nfunction LinkedList(title, image) {\n  this.length = 0;\n  this.head = null;\n}\n\nLinkedList.prototype.append = function(node) {\n  if (this.head == null) {\n    this.head = node;\n    return;\n  }\n  else {\n    var tmp = this.head;\n    while (tmp.pointer != null) {\n      tmp = tmp.pointer;\n    }\n    tmp.pointer = node;\n  }\n}\n\nLinkedList.prototype.list_values = function() {\n  var values = [];\n  if (this.head == null) {\n    return [];\n  }\n  else {\n    var tmp = this.head;\n    values.push(tmp.value);\n    while (tmp.pointer != null) {\n      tmp = tmp.pointer;\n      values.push(tmp.value);\n    }\n  }\n  return values;\n}\n"},{"name":"tests.js","value":"describe(\"Node\", function() {\n\n  it(\"should set a default value on a node\", function() {\n    var node = new Node();\n    expect(node.value).toEqual(\"default\");\n  });\n\n  it(\"should be able to set a value on the node during creation\", function() {\n    var node = new Node(\"defined value\");\n    expect(node.value).toEqual(\"defined value\");\n  });\n\n});\n\ndescribe(\"LinkedList\", function() {\n  var linked_list;\n\n  beforeEach(function() {\n    linked_list = new LinkedList();\n  });\n\n  it(\"should have a length of 0 by default\", function() {\n    expect(linked_list.list_values().length).toEqual(0);\n  });\n\n  it(\"should be able to add some nodes\", function() {\n    linked_list.append(new Node(\"foo\"));\n    linked_list.append(new Node(\"bar\"));\n    linked_list.append(new Node(\"baz\"));\n    expect(linked_list.list_values().length).toEqual(3);\n    expect(linked_list.list_values()[0]).toEqual(\"foo\");\n    expect(linked_list.list_values()[1]).toEqual(\"bar\");\n    expect(linked_list.list_values()[2]).toEqual(\"baz\");\n  });\n\n});\n"}]},"linked_list_python":{"files":[{"name":"Runner","value":"python_2_7_6\n"},{"name":"code.py","value":"class node:\n    def __init__(self):\n        self.data = None # contains the data\n        self.next = None # contains the reference to the next node\n\nclass linked_list:\n    def __init__(self):\n        self.cur_node = None\n\n    def add_node(self, data):\n        new_node = node() # create a new node\n        new_node.data = data\n        new_node.next = self.cur_node # link the new node to the 'previous' node.\n        self.cur_node = new_node #  set the current node to the new one.\n\n    def get_nth_node(self, nth):\n        node = self.cur_node\n        counter = 0\n        while node:\n            if counter == nth:\n                return node\n            counter += 1\n            node = node.next\n        return None\n\n    def length(self):\n        node = self.cur_node\n        length = 0\n        while node:\n            length += 1\n            node = node.next\n        return length\n"},{"name":"unittests.py","value":"from code import *\n\nimport unittest\n\nclass TestLinkedListFunctions(unittest.TestCase):\n\n    def test_no_elements(self):\n        ll = linked_list()\n        self.assertEqual(ll.length(), 0)\n\n    def test_insert(self):\n        ll = linked_list()\n        ll.add_node(1)\n        ll.add_node(2)\n        self.assertEqual(ll.length(), 2)\n\n    def test_inserted_node_when_empty(self):\n        ll = linked_list()\n        self.assertEqual(ll.get_nth_node(0), None)\n\n    def test_inserted_node_data(self):\n        ll = linked_list()\n        ll.add_node(1)\n        ll.add_node(5)\n        ll.add_node(10)\n        self.assertEqual(ll.get_nth_node(0).data, 10)\n        self.assertEqual(ll.get_nth_node(1).data, 5)\n        self.assertEqual(ll.get_nth_node(2).data, 1)\n        self.assertEqual(ll.get_nth_node(3), None)\n\nif __name__ == '__main__':\n    unittest.main()\n"}]},"stack_in_c":{"files":[{"name":"Runner","value":"c_check_0_9_12\n"},{"name":"code.c","value":"#include \"code.h\"\n\nbool create_stack(Node **stack) {\n    *stack = NULL;\n    return true;\n}\n\nbool push(Node **stack_ptr_ptr, int value) {\n\n    Node *newnode;\n    newnode = (Node *) malloc(sizeof(Node));\n    if (newnode == NULL) {\n        // The memory allocation failed\n        return false;\n    }\n\n    newnode->value = value;\n\n    if (stack_ptr_ptr == NULL) {\n        *stack_ptr_ptr = newnode;\n    }\n    else {\n        newnode->nxt = *stack_ptr_ptr;\n        *stack_ptr_ptr = newnode;\n    }\n\n    return true;\n}\n\nbool pop(Node **stack_ptr_ptr, int *value) {\n    Node *node_ptr;\n    if (!(node_ptr = *stack_ptr_ptr)) {\n        *value = 0;\n        return false;\n    }\n\n    *value = node_ptr->value;\n    *stack_ptr_ptr = node_ptr->nxt;\n    free(node_ptr);\n    return true;\n}\n\nbool delete_stack(Node **stack) {\n\n    Node *next;\n    while(*stack) {\n        next = (*stack)->nxt;\n        free(*stack);\n        *stack = next;\n    }\n\n    return true;\n"},{"name":"code.h","value":"#ifndef CS_CODE_\n#define CS_CODE_\n\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Node\n{\n    struct Node *nxt;\n    int value;\n} Node;\n\nbool create_stack(Node **stack);\nbool push(Node **stack, int value);\nbool pop(Node **stack, int *value);\nbool delete_stack(Node **stack);\n\n#endif  // CS_CODE_\n"},{"name":"unittests.c","value":"#include \"code.h\"\n#include \"/check-framework/src/check.h\"\n#include <stdio.h>\n\nSTART_TEST (test_create_push_pop_delete)\n{\n  // Create\n  Node **stack;\n  fail_unless(create_stack(stack) == true, \"the stack was successfully created\");\n\n  // Push\n  fail_unless( push(stack, 6) == true, \"6 was successfully pushed onto the stack\");\n  fail_unless( (*stack)->value == 6, \"the internals are correct\");\n  fail_unless( push(stack, 10) == true, \"10 was successfully pushed onto the stack\");\n  fail_unless( (*stack)->value == 10, \"the internals are correct\");\n\n  // Pop\n  int popped_value = 0;\n  fail_unless(pop(stack, &popped_value) == true, \"The first pop succeeded\");\n  fail_unless(popped_value == 10, \"The most recent value\");\n\n  fail_unless(pop(stack, &popped_value) == true, \"The second pop succeeded\");\n  fail_unless(popped_value == 6, \"The initial value\");\n  \n  fail_unless(pop(stack, &popped_value) == false, \"The pop failed because the stack is empty\");\n  fail_unless(popped_value == 0, \"The most recent value is 0\");\n\n  // Delete\n  fail_unless(delete_stack(stack) == true, \"The stack was successfully deleted\");\n\n}\nEND_TEST\n\nSuite * stack_suite (void) {\n  Suite *s = suite_create (\"Stack\");\n\n  TCase *tc_core = tcase_create (\"Core\");\n  tcase_add_test (tc_core, test_create_push_pop_delete);\n  suite_add_tcase (s, tc_core);\n\n  return s;\n}\n\nint main (void) {\n  int number_failed;\n  Suite *s = stack_suite ();\n  SRunner *sr = srunner_create (s);\n  srunner_run_all (sr, CK_NORMAL);\n  number_failed = srunner_ntests_failed (sr);\n  srunner_free (sr);\n  return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;\n}\n"}]},"stack_in_cc":{"files":[{"name":"Runner","value":"cc_gtest_1_7_0\n"},{"name":"code.cc","value":"#include \"code.h\"\n\nStack::Stack() {\n    head = NULL;\n    return;\n}\n\nStack::~Stack() {\n    while (head) {\n        Node *next = head->nxt;\n        delete head;\n        head = next;\n    }\n    return;\n}\n\nvoid Stack::push(int value) {\n    Node *node = new Node;\n    node->value = value;\n    node->nxt = head;\n    head = node;\n    return;\n}\n\nint Stack::pop() {\n    Node *popNode = head;\n    if (head == NULL) {\n        //[tag:todo:gem]\n        //throw StackError(E_EMPTY);\n        throw \"stack is empty\";\n    }\n\n    int value = head->value;\n    head = head->nxt;\n    delete popNode;\n    return value;\n}\n"},{"name":"code.h","value":"#ifndef CS_CODE_\n#define CS_CODE_\n\n#include <iostream>\n\n//#define E_EMPTY \"the stack is empty\"\n\nclass Stack {\n    public:\n        Stack();\n        ~Stack();\n        void push (int value);\n        int pop();\n    protected:\n        typedef struct Node {\n            struct Node *nxt;\n            int value;\n        } Node;\n\n    Node *head;\n};\n\n#endif  // CS_CODE_\n"},{"name":"unittests.cc","value":"#include \"code.h\"\n#include <gtest/gtest.h>\n\nTEST(StackTestGrouping, PushAndPop) {\n    Stack *stack = new Stack;\n\n    // Trying to pop off of an empty list causes an exception.\n    try {\n        stack->pop();\n        FAIL() << \"The pop should have thrown an exception\";\n    }\n    catch (...) {\n        //[tag:todo:gem]: rather than using a catchall, it would be great to\n        //actually catch the particular type of exception.\n        //[tag:todo:gem]: This failure is tested below, too.  Potentially refactor.\n        SUCCEED() << \"An exception was thrown, as expected.\";\n    }\n\n    stack->push(4);\n    EXPECT_EQ(4, stack->pop());\n\n    stack->push(6);\n    stack->push(7);\n    EXPECT_EQ(7, stack->pop());\n    EXPECT_EQ(6, stack->pop());\n\n    // Trying to pop off of an empty list causes an exception.\n    try {\n        stack->pop();\n        FAIL() << \"The pop should have thrown an exception\";\n    }\n    catch (...) {\n        //[tag:todo:gem]: rather than using a catchall, it would be great to\n        //actually catch the particular type of exception.\n        SUCCEED() << \"An exception was thrown, as expected.\";\n    }\n\n    //[tag:todo:gem] we should somehow test the destructor, too\n}\n\nint main(int argc, char **argv) {\n  ::testing::InitGoogleTest(&argc, argv);\n  return RUN_ALL_TESTS();\n}\n"}]},"stack_in_ruby":{"files":[{"name":"Runner","value":"ruby_1_9_3\n"},{"name":"code.rb","value":"class Node\n\n  attr_accessor :nxt, :value\n\n  def initialize(value)\n    @value = value\n    @nxt = nil\n  end\n\nend\n\n\nclass Stack\n\n  attr_reader :head\n\n  def initialize()\n    @head = nil \n  end\n\n  def push(value)\n    node = Node.new(value)\n    if @head != nil\n      node.nxt = @head\n    end\n    @head = node\n  end\n\n  def pop\n    if @head == nil\n      return nil\n    else\n      old = @head\n      @head = @head.nxt\n      value = old.value\n      # [tag:todo:gem] Need to delete \"old\"\n      return value\n    end\n  end\n\nend\n"},{"name":"unittests.rb","value":"require 'test/unit'\n\nrequire_relative \"./code.rb\"\n\nclass TC_Stack < Test::Unit::TestCase\n\n  def test_stack_push_pop\n    stack = Stack.new()\n\n    # Push one thing onto the stack, then pop it off\n    assert_equal nil, stack.head()\n    assert_equal nil, stack.pop()\n    stack.push(5)\n    assert_equal 5, stack.pop()\n    assert_equal nil, stack.pop()\n\n    # Push multiple things onto the stack, then pop them off\n    assert_equal nil, stack.pop()\n    stack.push(10)\n    stack.push(20)\n    stack.push(30)\n    assert_equal 30, stack.pop()\n    assert_equal 20, stack.pop()\n    assert_equal 10, stack.pop()\n    assert_equal nil, stack.pop()\n  end\n\nend\n"}]}}